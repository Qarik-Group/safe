#!/bin/bash
FAIL_FAST="${FAIL_FAST:-}"
set -u

rc=0
platform=
arch=amd64
old_home="$HOME"
vault_pid=

case $OSTYPE in
(darwin*)
	platform=darwin
	declare -a versions=(
		0.6.5
		0.7.3
	)
	;;
(linux*)
	platform=linux
	declare -a versions=(
		0.5.0
		0.5.2
		0.6.4
		0.6.5
		0.7.3
	)
	;;
(*)
	echo >&2 "UNRECOGNIZED OSTYPE '$OSTYPE'"
	exit 1
	;;
esac


bail() {
	echo >&2 $*
	exit 2
}
testing() {
  if [[ $rc -ne 0 && -n $FAIL_FAST ]] ; then
		dump_log 1
		echo "Failure encountered, stopping tests!"
		exit 4
	fi
	rm -f t/home/got t/home/want t/home/diff t/home/errors
	local v=$1 ; shift
	echo -n "[$v] $*... "
}
diffok() {
	if [[ -f t/home/errors && -s t/home/errors ]]; then
		echo "FAILED! (with errors:)"
		rc=1
		cat t/home/errors
		echo ; echo
	elif ! diff -u t/home/got t/home/want >t/home/diff 2>&1; then
		echo "FAILED!"
		rc=1
		cat t/home/diff
		echo ; echo
	else
		echo "ok"
	fi
}
yamlok() {
	[ -s t/home/got ] || echo "--- {}" > t/home/got
	spruce merge t/home/got  > t/home/got.x   ; mv t/home/got.x  t/home/got
	spruce merge t/home/want > t/home/want.x  ; mv t/home/want.x t/home/want
	diffok
}
exitok() {
	if [[ $1 -eq $2 ]]; then
		echo "ok"
	else
		echo "FAILED!"
		rc=1
		echo " expected process to exit $2"
		echo "   but it actually exited $1"
	fi
}

dump_log() {
	if [[ -f t/home/log ]] ; then
		if grep -q 'goroutine' t/home/log; then
			exit 77 # ./try will pick up on this error code
		fi
		if [[ ${rc} -ne 0 || -n ${1:-} ]]; then
			echo
			echo >&2 "---[ VAULT LOG ]------------------------------------------"
			cat  >&2 t/home/log
			echo >&2 "----------------------------------------------------------"
			echo
		fi
	fi
}

kill_running_vault() {
	if [[ -n $vault_pid ]] ; then
		kill $vault_pid
		vault_pid=
	fi
}

cleanup() {
	export HOME=${old_home}
	rm -rf t/
	kill_running_vault

	if [[ ${rc} -eq 0 ]]; then
		echo PASSED
	else
		echo FAILED
	fi
	exit ${rc}
}


mkdir -p vaults t/tmp
trap 'cleanup' INT QUIT TERM EXIT

for version in ${versions[@]}; do
	killall vault-${platform}-${version} >/dev/null 2>&1 || true
done
for version in ${versions[@]}; do
	echo "VAULT ${version}"
	killall vault-${platform}-${version} >/dev/null 2>&1 || true
	echo "----------------------------------------------"
	if [[ ! -f vaults/vault-${platform}-${version} ]]; then
		echo "Downloading Vault ${version} CLI..."
		curl --fail -L > t/tmp/archive.zip \
			https://releases.hashicorp.com/vault/${version}/vault_${version}_${platform}_${arch}.zip \
			|| bail "download of vault ${version} failed"

		unzip -d t/tmp t/tmp/archive.zip
		mv t/tmp/vault vaults/vault-${platform}-${version}
		echo "DONE"
		echo
	fi

	old_home=$HOME
	export HOME=${PWD}/t/home

	rm -rf t/home ; mkdir -p t/home
	#trap "rm -rf t/home" INT TERM QUIT EXIT
  
	kill_running_vault
	./vaults/vault-${platform}-${version} server -dev >t/home/log 2>&1 &
	vault_pid=$!
	waitfor=600
	while ! grep -iq '^root token: ' t/home/log; do
		if [[ $waitfor -gt 0 ]]; then
			waitfor=$((waitfor - 1))
			sleep 0.1
		else
			echo "FAILED - timed out waiting for vault server (-dev) to start"
			dump_log 1
			exit 3 # FIXME: this is the wrong thing to do
		fi
	done

	root_token=$(awk '/^Root Token:/ { print $3 }' < t/home/log | head -n1)
	unseal_key=$(awk '/^Unseal Key:/ { print $3 }' < t/home/log | head -n1)

	./safe target unit-tests http://127.0.0.1:8200
	./safe auth token <<<${root_token}

	testing $version basic set/get operation
	./safe set secret/handshake knock=knock >/dev/null
	./safe ask secret/handshake whos=there >/dev/null
	./safe get secret/handshake >t/home/got 2>t/home/errors
	cat >t/home/want <<EOF
--- # secret/handshake
knock: knock
whos: there
EOF
	yamlok

	testing $version get operation with --yaml on single path
	./safe get --yaml secret/handshake >t/home/got 2>t/home/errors
	cat >t/home/want <<EOF
---
secret/handshake:
  knock: knock
  whos: there
EOF
	yamlok

  testing $version get operation: multiple requests, some missing
  ./safe set secret/other/thing get=this > /dev/null
  ./safe get secret/handshake secret/other/thing secret/non-existant secret/handshake:passcode >t/home/got 2>&1 ; exitok $? 1
  cat >t/home/want <<'EOF' ;
!! Multiple errors found:
   - no secret exists at path `secret/non-existant`
   - no key `passcode` exists in secret `secret/handshake`
EOF
  diffok

  testing $version get operation: multiple requests
  ./safe get secret/handshake secret/other/thing >t/home/got 2>t/home/errors ; exitok $? 0
  cat >t/home/want <<'EOF' ; yamlok
---
secret/handshake:
  knock: knock
  whos: there
secret/other/thing:
  get: this
EOF

  testing $version get --keys operation: multiple requests, some missing
  ./safe get --keys secret/handshake secret/other/thing secret/code:pssst >t/home/got 2>t/home/warn ; exitok $? 0
  cat >t/home/want <<'EOF' ;
---
secret/handshake:
- knock
- whos
secret/other/thing:
- get
secret/code: []
EOF
  yamlok

  mv t/home/warn t/home/got
  cat >t/home/want <<'EOF'; diffok
WARNING: no secret exists at path `secret/code`
EOF


  testing $version get --keys operation: single key
  ./safe get --keys secret/handshake >t/home/got 2>&1 ; exitok $? 0
  cat >t/home/want <<'EOF'
knock
whos
EOF
  diffok

  testing $version get --keys operation: single key with --yaml
  ./safe get --keys --yaml secret/handshake >t/home/got 2>&1 ; exitok $? 0
  cat >t/home/want <<'EOF'
---
secret/handshake:
- knock
- whos
EOF
  yamlok

	testing $version basic check/exists operation
	./safe exists secret/handshake        ; exitok $? 0
	./safe exists secret/handshake:knock  ; exitok $? 0
	./safe exists secret/handshake:enoent ; exitok $? 1
	./safe exists secret/enoent           ; exitok $? 1
	./safe exists secret/enoent:sub       ; exitok $? 1

	testing $version multiple-attribute set operation
	./safe set secret/account username=admin password=sekrit >/dev/null
	./safe get secret/account >t/home/got 2>t/home/errors
	cat >t/home/want <<EOF
--- # secret/account
username: admin
password: sekrit
EOF
	yamlok

	testing $version password randomization
	./safe gen secret/random one     >/dev/null
	./safe gen secret/random another >/dev/null
	./safe get secret/random | spruce json >t/home/got 2>t/home/errors
	one=$(jq -r .one < t/home/got)
	another=$(jq -r .another < t/home/got)
	if [[ ${one} == ${another} ]]; then
		echo "FAILED"
		rc=1
		echo "  ... expected generated password '${one}'"
		echo "            to not be the same as '${another}'"
	else
		echo "ok"
	fi

	testing $version command chaining
	./safe gen secret/chained a -- gen secret/chained b -- gen secret/chained c >/dev/null
	./safe get secret/chained | spruce json > t/home/got 2>t/home/errors
	for k in a b c; do
		v=$(jq -r .$k < t/home/got)
		if [[ -z "$v" ]]; then
			echo "FAILED"
			rc=1
			echo "  ... expected secret/chained/$k to exist"
		else
			echo "ok"
		fi
	done


	testing $version custom password runes randomization

	./safe gen --policy "1-9" 64 secret/random one #    >/dev/null
	./safe get secret/random | spruce json >t/home/runed # 2>t/home/errors

	one=$(jq -r .one < t/home/runed)
	if [[ "$one" =~ ^[1-9]+$ ]]; then
		echo "ok"
	else
		echo "FAILED"
		rc=1
		echo "  expected generated password: '$one'"
		echo "              to only contain: [1-9]"
	fi

	testing $version password with secret:key syntax
	./safe gen 64 secret/random:two
	exitok $? 0
	./safe get secret/random:two
	exitok $? 0

	testing $version gen with multiple passwords to make
	./safe gen 64 secret/random:three secret/random four secret/random:five
	exitok $? 0
	./safe get secret/random:three; exitok $? 0
	./safe get secret/random:four; exitok $? 0
	./safe get secret/random:five; exitok $? 0

	testing $version gen with length flag
	./safe gen secret/random:six -l 10
	./safe get secret/random:six | tr -d '\n' >t/home/got
	if [[ $(cat t/home/got | wc -m) -ne 10 ]]; then
	  echo "FAILED"
		rc=1
		echo "Expected generated password to have 10 characters"
		echo "Got $(cat t/home/got | wc -m) instead"
  fi

	testing $version gen with incorrectly mixed path:key should fail
	./safe gen secret/random secret/random:seven 2>/dev/null; exitok $? 1

	testing $version gen with missing key should fail
	./safe gen secret/random 2>/dev/null; exitok $? 1

	testing $version single-value retrieval
	./safe set secret/single/value foo=bar baz=quux >/dev/null
	foo=$(./safe get secret/single/value:foo)
	if [[ ${foo} != "bar" ]]; then
		echo "FAILED"
		rc=1
		echo "  ... expected foo='bar'"
		echo "               got '${foo}'"
	else
		echo "ok"
	fi

	testing $version set key from file
	echo -n "this is a value" >t/home/value-file
	echo -n "" >t/home/empty-file
	cat >t/home/long-file <<EOF
this
is
a
multiline
value
EOF
	./safe set secret/from-files/content value@t/home/value-file blank@t/home/empty-file long@t/home/long-file ; exitok $? 0
	./safe get secret/from-files/content --yaml >t/home/got 2>t/home/errors ; exitok $? 0
	cat >t/home/want <<EOF ; cp t/home/want /tmp; yamlok
---
secret/from-files/content:
  value: this is a value
  blank: ""
  long: |
    this
    is
    a
    multiline
    value
EOF

	testing $version set key to empty value
	./safe set secret/setec/astronomy too= many="" ; exitok $? 0
	./safe get secret/setec/astronomy --yaml >t/home/got 2>t/home/errors ; exitok $? 0
	cat >t/home/want <<EOF ; cp t/home/want /tmp; yamlok
---
secret/setec/astronomy:
  too: ""
  many: ""
EOF

	testing $version set key from file - error conditions
	./safe set secret/from-file/content nothing@non-existant-file 2>t/home/got >t/home/null; exitok $? 1
	cat > t/home/want<<EOF ; diffok
!! Failed to read contents of non-existant-file: open non-existant-file: no such file or directory
EOF
	mv -f t/home/null t/home/got
	echo -n "" > t/home/want ; diffok
	./safe get secret/from-file/content:nothing; exitok $? 1

	./safe set secret/from-file/content no-file@ 2>t/home/got >t/home/null; exitok $? 1
	cat > t/home/want<<EOF ; diffok
!! No file specified: expecting no-file@<filename>
EOF
	mv -f t/home/null t/home/got
	echo -n "" > t/home/want ; diffok
	./safe get secret/from-file/content:no-file; exitok $? 1
	

	###### DELETE TESTS ######

	testing $version secret deletion
	./safe set secret/delete/one hello=world
	./safe delete secret/delete/one; exitok $? 0
	./safe get secret/delete/one; exitok $? 1

	testing $version multiple secret deletion
	./safe set secret/delete/two foo=bar
	./safe set secret/delete/three wom=bat
	./safe delete secret/delete/two secret/delete/three; exitok $? 0
	./safe get secret/delete/two; exitok $? 1
	./safe get secret/delete/three; exitok $? 1

	testing $version key deletion with key remaining within secret afterwards
	./safe set secret/delete/four foo=bar wom=bat
	./safe delete secret/delete/four:wom; exitok $? 0
	./safe get secret/delete/four:wom; exitok $? 1
	./safe get secret/delete/four:foo; exitok $? 0

	testing $version key deletion with no keys remaining should delete secret
	./safe set secret/delete/five foo=bar
	./safe delete secret/delete/five:foo; exitok $? 0
	./safe get secret/delete/five; exitok $? 1

	testing $version multiple key deletion
	./safe set secret/delete/six foo=bar wom=bat beep=boop
	./safe delete secret/delete/six:foo secret/delete/six:wom; exitok $? 0
	./safe get secret/delete/six:foo; exitok $? 1
	./safe get secret/delete/six:wom; exitok $? 1
	./safe get secret/delete/six:beep; exitok $? 0

	testing $version attempt to delete non-existent key should fail
	./safe delete secret/delete/gobbledegook; exitok $? 1

	testing $version attempt to delete non-existing key within existing secret should error
	./safe set secret/delete/seven foo=bar
	./safe delete secret/delete/seven:gobbledegook; exitok $? 1
	./safe get secret/delete/seven:foo; exitok $? 0

	testing $version delete non-existent key should not fail if -f is given
	./safe delete secret/delete/gobbledegook -f; exitok $? 0

	testing $version deleting non-existent key with -f specified should fail silently
	./safe set secret/delete/eight foo=bar
	./safe delete secret/delete/eight:gobbledegook -f; exitok $? 0
	./safe get secret/delete/eight:foo; exitok $? 0

	testing $version recursively delete a subtree
	./safe set secret/delete/subtree1/one foo=bar
	./safe set secret/delete/subtree1/two beep=boop
	./safe delete -Rf secret/delete/subtree1; exitok $? 0
	./safe get secret/delete/subtree1/one; exitok $? 1
	./safe get secret/delete/subtree1/two; exitok $? 1

	testing $version attempting to delete a subtree without -R should fail
	./safe set secret/delete/subtree2/one foo=bar
	./safe set secret/delete/subtree2/two foo=bar
	./safe delete -f secret/delete/subtree2; exitok $? 1
	cat >t/home/want <<EOF
bar
EOF
	./safe get secret/delete/subtree2/one:foo >t/home/got 2>t/home/errors; diffok
	./safe get secret/delete/subtree2/two:foo >t/home/got 2>t/home/errors; diffok

	testing $version recursively delete a leaf node secret
	./safe set secret/delete/nine foo=bar
	./safe delete -Rf secret/delete/nine; exitok $? 0
	./safe get secret/delete/nine; exitok $? 1

	testing $version recursively delete a key
	./safe set secret/delete/ten foo=bar beep=boop
	./safe delete -Rf secret/delete/ten:foo
	./safe get secret/delete/ten:foo; exitok $? 1
	cat >t/home/want <<EOF
boop
EOF
	./safe get secret/delete/ten:beep >t/home/got 2>t/home/errors; diffok

	testing $version recursively delete a secret that does not exist with -f should not fail
	./safe delete -Rf secret/delete/gobbledegook; exitok $? 0

	testing $version recursively delete a key that does not exist with -f should not fail
	./safe set secret/delete/eleven beep=boop
	./safe delete -Rf secret/delete/eleven:foo; exitok $? 0
	cat >t/home/want <<EOF
boop
EOF
	./safe get secret/delete/eleven:beep >t/home/got 2>t/home/errors; diffok

	###### COPY TESTS ######

	testing $version copy a secret to another location
	./safe set secret/copy/from1 beep=boop
	./safe copy secret/copy/from1 secret/copy/to1; exitok $? 0
	cat >t/home/want <<EOF
boop
EOF
	./safe get secret/copy/from1:beep >t/home/got 2>t/home/errors; diffok
	./safe get secret/copy/to1:beep >t/home/got 2>t/home/errors; diffok


	testing $version copy a key to another secret without a key specified
	./safe set secret/copy/from2 beep=boop foo=bar
	./safe copy secret/copy/from2:beep secret/copy/to2; exitok $? 0
	cat >t/home/want <<EOF
boop
EOF
	./safe get secret/copy/from2:beep >t/home/got 2>t/home/errors; diffok
	./safe get secret/copy/to2:beep >t/home/got 2>t/home/errors; diffok
	cat >t/home/want <<EOF
bar
EOF
  ./safe get secret/copy/from2:foo >t/home/got 2>t/home/errors; diffok
	./safe get secret/copy/to2:foo; exitok $? 1


	testing $version copy a key to another specified key where the dest secret exists
	./safe set secret/copy/from3 beep=boop foo=bar
	./safe set secret/copy/to3 wom=bat
	./safe copy secret/copy/from3:beep secret/copy/to3:another; exitok $? 0
	cat >t/home/want <<EOF
boop
EOF
	./safe get secret/copy/from3:beep >t/home/got 2>t/home/errors; diffok
	./safe get secret/copy/to3:another >t/home/got 2>t/home/errors; diffok
	cat >t/home/want <<EOF
bar
EOF
  ./safe get secret/copy/from3:foo >t/home/got 2>t/home/errors; diffok
	./safe get secret/copy/to3:foo; exitok $? 1
cat >t/home/want <<EOF
bat
EOF
  ./safe get secret/copy/to3:wom >t/home/got 2>t/home/errors; diffok


	testing $version copy a key to another specified key where the dest secret does not exist
	./safe set secret/copy/from4 beep=boop foo=bar
	./safe copy secret/copy/from4:beep secret/copy/to4:another; exitok $? 0
	cat >t/home/want <<EOF
boop
EOF
	./safe get secret/copy/from3:beep >t/home/got 2>t/home/errors; diffok
	./safe get secret/copy/to3:another >t/home/got 2>t/home/errors; diffok
	cat >t/home/want <<EOF
bar
EOF
  ./safe get secret/copy/from3:foo >t/home/got 2>t/home/errors; diffok
	./safe get secret/copy/to3:foo; exitok $? 1


	testing $version copying a full secret to a specified key should fail
	./safe set secret/copy/from5 beep=boop
	./safe copy secret/copy/from5 secret/copy/to5:hello; exitok $? 1
	cat >t/home/want <<EOF
boop
EOF
	./safe get secret/copy/from5:beep >t/home/got 2>t/home/errors; diffok


	testing $version copying from a secret that does not exist should fail
	./safe copy secret/copy/from6 secret/copy/to6; exitok $? 1


	testing $version copying from a key where the underlying secret does not exist should fail
	./safe copy secret/copy/from7:beep secret/copy/to7; exitok $? 1


	testing $version copying from a missing key where the underlying secret exists should fail
	./safe set secret/copy/from8 foo=bar
	./safe copy secret/copy/from8:beep secret/copy/to8; exitok $? 1

	testing $version copying recursively from a leaf node secret
	./safe set secret/copy/from9 foo=bar
	./safe copy -Rf secret/copy/from9 secret/copy/to9; exitok $? 0
	cat >t/home/want <<EOF
bar
EOF
	./safe get secret/copy/from9:foo >t/home/got 2>t/home/errors; diffok
	./safe get secret/copy/to9:foo >t/home/got 2>t/home/errors; diffok

	testing $version copying recursively from a key
	./safe set secret/copy/from10 foo=bar
	./safe copy -Rf secret/copy/from10:foo secret/copy/to10; exitok $? 0
	cat >t/home/want <<EOF
bar
EOF
	./safe get secret/copy/from10:foo >t/home/got 2>t/home/errors; diffok
	./safe get secret/copy/to10:foo >t/home/got 2>t/home/errors; diffok

	testing $version copying recursively from a subtree
	./safe set secret/copy/fromtree1/one foo=bar
	./safe copy -Rf secret/copy/fromtree1 secret/copy/totree1; exitok $? 0
	cat >t/home/want <<EOF
bar
EOF
	./safe get secret/copy/fromtree1/one:foo >t/home/got 2>t/home/errors; diffok
	./safe get secret/copy/totree1/one:foo >t/home/got 2>t/home/errors; diffok

	testing $version attempting to copy a subtree without -R should fail
	./safe set secret/copy/fromtree2/one foo=bar
	./safe copy -f secret/copy/fromtree2 secret/copy/totree2; exitok $? 1
	./safe get secret/copy/totree2/one; exitok $? 1

	testing $version copying a non-existent secret with -f should fail silently
	./safe copy -f secret/copy/gobbledegook secret/copy/fakedest; exitok $? 0
	./safe get secret/copy/fakedest; exitok $? 1

	testing $version copying a non-existent key with -f should fail silently
	./safe set secret/copy/from11 foo=bar
	./safe copy -f secret/copy/from11:beep secret/copy/to11; exitok $? 0
	./safe get secret/copy/to11; exitok $? 1

	###### MOVE TESTS ######

	testing $version move a secret to another location
	./safe set secret/move/from1 beep=boop
	./safe move secret/move/from1 secret/move/to1; exitok $? 0
	cat >t/home/want <<EOF
boop
EOF
	./safe get secret/move/from1:beep; exitok $? 1
	./safe get secret/move/to1:beep >t/home/got 2>t/home/errors; diffok


	testing $version move a key to another secret without a key specified
	./safe set secret/move/from2 beep=boop foo=bar
	./safe move secret/move/from2:beep secret/move/to2; exitok $? 0
	cat >t/home/want <<EOF
boop
EOF
	./safe get secret/move/from2:beep; exitok $? 1
	./safe get secret/move/to2:beep >t/home/got 2>t/home/errors; diffok
	cat >t/home/want <<EOF
bar
EOF
  ./safe get secret/move/from2:foo >t/home/got 2>t/home/errors; diffok
	./safe get secret/move/to2:foo; exitok $? 1


	testing $version move a key to another specified key where the dest secret exists
	./safe set secret/move/from3 beep=boop foo=bar
	./safe set secret/move/to3 wom=bat
	./safe move secret/move/from3:beep secret/move/to3:another; exitok $? 0
	cat >t/home/want <<EOF
boop
EOF
	./safe get secret/move/from3:beep; exitok $? 1
	./safe get secret/move/to3:another >t/home/got 2>t/home/errors; diffok
	cat >t/home/want <<EOF
bar
EOF
  ./safe get secret/move/from3:foo >t/home/got 2>t/home/errors; diffok
	./safe get secret/move/to3:foo; exitok $? 1
cat >t/home/want <<EOF
bat
EOF
  ./safe get secret/move/to3:wom >t/home/got 2>t/home/errors; diffok


	testing $version move a key to another specified key where the dest secret does not exist
	./safe set secret/move/from4 beep=boop foo=bar
	./safe move secret/move/from4:beep secret/move/to4:another; exitok $? 0
	cat >t/home/want <<EOF
boop
EOF
	./safe get secret/move/from3:beep; exitok $? 1
	./safe get secret/move/to3:another >t/home/got 2>t/home/errors; diffok
	cat >t/home/want <<EOF
bar
EOF
  ./safe get secret/move/from3:foo >t/home/got 2>t/home/errors; diffok
	./safe get secret/move/to3:foo; exitok $? 1


	testing $version moving a full secret to a specified key should fail
	./safe set secret/move/from5 beep=boop
	./safe move secret/move/from5 secret/move/to5:beep; exitok $? 1
	cat >t/home/want <<EOF
boop
EOF
	./safe get secret/move/from5:beep >t/home/got 2>t/home/errors; diffok


	testing $version moving from a secret that does not exist should fail
	./safe move secret/copy/from6 secret/move/to6; exitok $? 1


	testing $version moving from a key where the underlying secret does not exist should fail
	./safe move secret/move/from7:beep secret/move/to7; exitok $? 1


	testing $version moving from a missing key where the underlying secret exists should fail
	./safe set secret/move/from8 foo=bar
	./safe move secret/move/from8:beep secret/move/to8; exitok $? 1


	testing $version moving recursively from a leaf node secret
	./safe set secret/move/from9 foo=bar
	./safe move -Rf secret/move/from9 secret/move/to9; exitok $? 0
	cat >t/home/want <<EOF
bar
EOF
	./safe get secret/move/from9; exitok $? 1
	./safe get secret/move/to9:foo >t/home/got 2>t/home/errors; diffok


	testing $version moving recursively from a key
	./safe set secret/move/from10 foo=bar
	./safe move -Rf secret/move/from10:foo secret/move/to10; exitok $? 0
	cat >t/home/want <<EOF
bar
EOF
	./safe get secret/move/from9; exitok $? 1
	./safe get secret/copy/to9:foo >t/home/got 2>t/home/errors; diffok


	testing $version moving recursively from a subtree
	./safe set secret/move/fromtree1/one foo=bar
	./safe move -Rf secret/move/fromtree1 secret/move/totree1; exitok $? 0
	cat >t/home/want <<EOF
bar
EOF
	./safe get secret/move/fromtree1/one; exitok $? 1
	./safe get secret/move/totree1/one:foo >t/home/got 2>t/home/errors; diffok

	testing $version attempting to copy a subtree without -R should fail
	./safe set secret/move/fromtree2/one foo=bar
	./safe move -f secret/move/fromtree2 secret/move/totree2; exitok $? 1
	./safe get secret/move/totree2/one; exitok $? 1

	testing $version moving a non-existent secret with -f should fail silently
	./safe move -f secret/move/gobbledegook secret/move/fakedest; exitok $? 0
	./safe get secret/move/fakedest; exitok $? 1

	testing $version moving a non-existent key with -f should fail silently
	./safe set secret/move/from11 foo=bar
	./safe copy -f secret/move/from11:beep secret/move/to11; exitok $? 0
	./safe get secret/move/to11; exitok $? 1
	cat >t/home/want <<EOF
bar
EOF
	./safe get secret/move/from11:foo >t/home/got 2>t/home/errors; diffok

  ###### --no-clobber TESTS #####
	testing $version --no-clobber gen functionality without existing data
	./safe --no-clobber gen secret/existing/gen val >t/home/got 2>&1; exitok $? 0
	cat >t/home/want <<EOF ; diffok
EOF
	expected=$(./safe get secret/existing/gen)
	testing $version --no-clobber gen functionality with existing data
	./safe --no-clobber gen secret/existing/gen val >t/home/got 2>&1; exitok $? 0
	cat >t/home/want <<EOF ; diffok
Cowardly refusing to update secret/existing/gen:val as it is already present in Vault
EOF
	./safe --quiet --no-clobber gen secret/existing/gen val >t/home/got 2>&1; exitok $? 0
	cat >t/home/want <<EOF ; diffok
EOF
	./safe get secret/existing/gen >t/home/got; exitok $? 0
	cat >t/home/want <<EOF ; diffok
$expected

EOF

	testing $version --no-clobber set functionality without existing data
	./safe --no-clobber set secret/existing/set val=test >t/home/got 2>&1; exitok $? 0
	cat >t/home/want <<EOF ; diffok
val: test
EOF
	expected=$(./safe get secret/existing/set)
	testing $version --no-clobber set functionality with existing data
	./safe --no-clobber set secret/existing/set val=test2 >t/home/got 2>&1; exitok $? 0
	cat >t/home/want <<EOF ; diffok
val: test2
Cowardly refusing to update secret/existing/set, as the following keys would be clobbered: val
EOF
	./safe --quiet --no-clobber set secret/existing/set val=test2 >t/home/got 2>&1; exitok $? 0
	cat >t/home/want <<EOF ; diffok
val: test2
EOF
	./safe get secret/existing/set >t/home/got; exitok $? 0
	cat >t/home/want <<EOF ; diffok
$expected

EOF
	testing $version --no-clobber set functionality with different key in same path 
	./safe --no-clobber set secret/existing/set2 val=test; exitok $? 0
	./safe --no-clobber set secret/existing/set2 val2=test2 >t/home/got 2>&1; exitok $? 0
	cat >t/home/want <<EOF ; diffok
val2: test2
EOF
	./safe --no-clobber get secret/existing/set2 >t/home/got 2>&1; exitok $? 0
	cat >t/home/want <<EOF ; diffok
--- # secret/existing/set2
val: test
val2: test2

EOF

	testing $version --no-clobber paste functionality without existing data
	./safe --no-clobber paste secret/existing/paste val=test >t/home/got 2>&1; exitok $? 0
	cat >t/home/want <<EOF ; diffok
val: test
EOF
	expected=$(./safe get secret/existing/paste)
	testing $version --no-clobber paste functionality with existing data
	./safe --no-clobber paste secret/existing/paste val=test2 >t/home/got 2>&1; exitok $? 0
	cat >t/home/want <<EOF ; diffok
val: test2
Cowardly refusing to update secret/existing/paste, as the following keys would be clobbered: val
EOF
	./safe --quiet --no-clobber paste secret/existing/paste val=test2 >t/home/got 2>&1; exitok $? 0
	cat >t/home/want <<EOF ; diffok
val: test2
EOF
	./safe get secret/existing/paste >t/home/got; exitok $? 0
	cat >t/home/want <<EOF ; diffok
$expected

EOF

	testing $version --no-clobber ask functionality without existing data
	./safe --no-clobber ask secret/existing/ask val=test >t/home/got 2>&1; exitok $? 0
	cat >t/home/want <<EOF ; diffok
val: test
EOF
	expected=$(./safe get secret/existing/ask)
	testing $version --no-clobber ask functionality with existing data
	./safe --no-clobber ask secret/existing/ask val=test2 >t/home/got 2>&1; exitok $? 0
	cat >t/home/want <<EOF ; diffok
val: test2
Cowardly refusing to update secret/existing/ask, as the following keys would be clobbered: val
EOF
	./safe --quiet --no-clobber ask secret/existing/ask val=test2 >t/home/got 2>&1; exitok $? 0
	cat >t/home/want <<EOF ; diffok
val: test2
EOF
	./safe get secret/existing/ask >t/home/got; exitok $? 0
	cat >t/home/want <<EOF ; diffok
$expected

EOF

	testing $version --no-clobber import functionality
	./safe --no-clobber import secret/existing/import <<EOF >t/home/got 2>&1; exitok $? 1
{"secret/existing/import":{"should": "not import"}}
EOF
	cat >t/home/want <<EOF ; diffok
!! --no-clobber is incompatible with safe import
safe import - Import name/value pairs into the current Vault
USAGE: safe import <backup/file.json
EOF

	testing $version --no-clobber move functionality without existing data
	./safe set secret/existing/to-move key=val
	./safe --quiet --no-clobber move secret/existing/to-move secret/move-existing >t/home/got 2>&1; exitok $? 0
	cat >t/home/want <<EOF ; diffok
EOF
	expected=$(./safe get secret/move-existing)
	testing $version --no-clobber move functionality with existing data
	./safe set secret/existing/to-move key=val2
	./safe --no-clobber move secret/existing/to-move secret/move-existing >t/home/got 2>&1; exitok $? 0
	cat >t/home/want <<EOF ; diffok
Cowardly refusing to copy/move data into secret/move-existing, as that would clobber existing data
EOF
	./safe set secret/existing/to-move key=val2
	./safe --quiet --no-clobber move secret/existing/to-move secret/move-existing >t/home/got 2>&1; exitok $? 0
	cat >t/home/want <<EOF ; diffok
EOF
	./safe get secret/move-existing >t/home/got; exitok $? 0
	cat >t/home/want <<EOF ; diffok
$expected

EOF

	testing $version --no-clobber move to key functionality without existing data
	./safe set secret/existing/key-move key=val
	./safe --no-clobber move secret/existing/key-move:key secret/existing/key-move:key2 >t/home/got 2>&1; exitok $? 0
	cat >t/home/want <<EOF ; diffok
EOF
	expected=$(./safe get secret/existing/key-move)
	testing $version --no-clobber move to key functionality with existing data
	./safe set secret/existing/key-move key=val2
	./safe --no-clobber move secret/existing/key-move:key secret/existing/key-move:key2 >t/home/got 2>&1; exitok $? 0
	cat >t/home/want <<EOF ; diffok
Cowardly refusing to copy/move data into secret/existing/key-move:key2, as that would clobber existing data
EOF
	./safe set secret/existing/key-move key=val2
	./safe --quiet --no-clobber move secret/existing/key-move:key secret/existing/key-move:key2 >t/home/got 2>&1; exitok $? 0
	cat >t/home/want <<EOF ; diffok
EOF
	./safe get secret/existing/key-move >t/home/got; exitok $? 0
	cat >t/home/want <<EOF ; diffok
$expected

EOF

	testing $version --no-clobber recursive move functionality without existing data
	./safe set secret/move-recursive/first key=val
	./safe set secret/move-recursive/second key=val
	./safe --no-clobber move -Rf secret/move-recursive secret/move-recursive-existing >t/home/got 2>&1; exitok $? 0
	cat >t/home/want <<EOF ; diffok
EOF
	testing $version --no-clobber recursive move functionality with existing data
	./safe set secret/move-recursive/first key=val2
	./safe set secret/move-recursive/second key=val2
	./safe set secret/move-recursive/third key=val2
	./safe --no-clobber move -Rf secret/move-recursive secret/move-recursive-existing >t/home/got 2>&1; exitok $? 0
	cat >t/home/want <<EOF ; diffok
Cowardly refusing to copy/move data into secret/move-recursive-existing, as the following paths would be clobbered:
- secret/move-recursive-existing/first
- secret/move-recursive-existing/second
EOF
	./safe set secret/move-recursive/first key=val2
	./safe set secret/move-recursive/second key=val2
	./safe set secret/move-recursive/third key=val2
	./safe --quiet --no-clobber move -Rf secret/move-recursive secret/move-recursive-existing >t/home/got 2>&1; exitok $? 0
	cat >t/home/want <<EOF ; diffok
EOF
	./safe paths secret/move-recursive-existing >t/home/got; exitok $? 0
	cat >t/home/want <<EOF ; diffok
secret/move-recursive-existing/first
secret/move-recursive-existing/second
EOF
	./safe get secret/move-recursive-existing/first >t/home/got; exitok $? 0
	cat >t/home/want <<EOF ; diffok
--- # secret/move-recursive-existing/first
key: val

EOF
	./safe get secret/move-recursive-existing/second >t/home/got; exitok $? 0
	cat >t/home/want <<EOF ; diffok
--- # secret/move-recursive-existing/second
key: val

EOF
	./safe paths secret/move-recursive>t/home/got; exitok $? 0
	cat >t/home/want <<EOF ; diffok
secret/move-recursive/first
secret/move-recursive/second
secret/move-recursive/third
EOF
	./safe get secret/move-recursive/first >t/home/got; exitok $? 0
	cat >t/home/want <<EOF ; diffok
--- # secret/move-recursive/first
key: val2

EOF
	./safe get secret/move-recursive/second >t/home/got; exitok $? 0
	cat >t/home/want <<EOF ; diffok
--- # secret/move-recursive/second
key: val2

EOF
	./safe get secret/move-recursive/third >t/home/got; exitok $? 0
	cat >t/home/want <<EOF ; diffok
--- # secret/move-recursive/third
key: val2

EOF

	testing $version --no-clobber copy functionality without existing data
	./safe set secret/existing/to-copy key=val
	./safe --no-clobber copy secret/existing/to-copy secret/copy-existing >t/home/got 2>&1; exitok $? 0
	cat >t/home/want <<EOF ; diffok
EOF
	expected=$(./safe get secret/copy-existing)
	testing $version --no-clobber copy functionality with existing data
	./safe set secret/existing/to-copy key=val2
	./safe --no-clobber copy secret/existing/to-copy secret/copy-existing >t/home/got 2>&1; exitok $? 0
	cat >t/home/want <<EOF ; diffok
Cowardly refusing to copy/move data into secret/copy-existing, as that would clobber existing data
EOF
	./safe set secret/existing/to-copy key=val2
	./safe --quiet --no-clobber copy secret/existing/to-copy secret/copy-existing >t/home/got 2>&1; exitok $? 0
	cat >t/home/want <<EOF ; diffok
EOF
	./safe get secret/copy-existing >t/home/got; exitok $? 0
	cat >t/home/want <<EOF ; diffok
$expected

EOF

	testing $version --no-clobber recurive copy functionality without existing data
	./safe set secret/copy-recursive/first key=val
	./safe set secret/copy-recursive/second key=val
	./safe --no-clobber copy -Rf secret/copy-recursive secret/copy-recursive-existing >t/home/got 2>&1; exitok $? 0
	cat >t/home/want <<EOF ; diffok
EOF
	testing $version --no-clobber recursive copy functionality with existing data
	./safe set secret/copy-recursive/first key=val2
	./safe set secret/copy-recursive/second key=val2
	./safe set secret/copy-recursive/third key=val2
	./safe --no-clobber copy -Rf secret/copy-recursive secret/copy-recursive-existing >t/home/got 2>&1; exitok $? 0
	cat >t/home/want <<EOF ; diffok
Cowardly refusing to copy/move data into secret/copy-recursive-existing, as the following paths would be clobbered:
- secret/copy-recursive-existing/first
- secret/copy-recursive-existing/second
EOF
	./safe set secret/copy-recursive/first key=val2
	./safe set secret/copy-recursive/second key=val2
	./safe set secret/copy-recursive/third key=val2
	./safe --quiet --no-clobber copy -Rf secret/copy-recursive secret/copy-recursive-existing >t/home/got 2>&1; exitok $? 0
	cat >t/home/want <<EOF ; diffok
EOF
	./safe paths secret/copy-recursive-existing >t/home/got; exitok $? 0
	cat >t/home/want <<EOF ; diffok
secret/copy-recursive-existing/first
secret/copy-recursive-existing/second
EOF
	./safe get secret/copy-recursive-existing/first >t/home/got; exitok $? 0
	cat >t/home/want <<EOF ; diffok
--- # secret/copy-recursive-existing/first
key: val

EOF
	./safe get secret/copy-recursive-existing/second >t/home/got; exitok $? 0
	cat >t/home/want <<EOF ; diffok
--- # secret/copy-recursive-existing/second
key: val

EOF

	testing $version --no-clobber ssh functionality without existing data
	./safe --no-clobber ssh secret/existing/ssh >t/home/got 2>&1; exitok $? 0
	cat >t/home/want <<EOF ; diffok
EOF
	expected=$(./safe get secret/existing/ssh)
	testing $version --no-clobber ssh functionality with existing data
	./safe --no-clobber ssh secret/existing/ssh >t/home/got 2>&1; exitok $? 0
	cat >t/home/want <<EOF ; diffok
Cowardly refusing to generate an SSH key at secret/existing/ssh as it is already present in Vault
EOF
	./safe --quiet --no-clobber ssh secret/existing/ssh >t/home/got 2>&1; exitok $? 0
	cat >t/home/want <<EOF ; diffok
EOF
	./safe get secret/existing/ssh >t/home/got 2>&1; exitok $? 0
	cat >t/home/want <<EOF ; diffok
$expected

EOF

	testing $version --no-clobber rsa functionality without existing data
	./safe --no-clobber rsa secret/existing/rsa >t/home/got 2>&1; exitok $? 0
	cat >t/home/want <<EOF ; diffok
EOF
	expected=$(./safe get secret/existing/rsa)
	testing $version --no-clobber rsa functionality with existing data
	./safe --no-clobber rsa secret/existing/rsa >t/home/got 2>&1; exitok $? 0
	cat >t/home/want <<EOF ; diffok
Cowardly refusing to generate an RSA key at secret/existing/rsa as it is already present in Vault
EOF
	./safe --quiet --no-clobber rsa secret/existing/rsa >t/home/got 2>&1; exitok $? 0
	cat >t/home/want <<EOF ; diffok
EOF
	./safe get secret/existing/rsa >t/home/got; exitok $? 0
	cat >t/home/want <<EOF ; diffok
$expected

EOF

	testing $version --no-clobber dhparam functionality without existing data
	./safe --no-clobber dhparam secret/existing/dhparam >t/home/got; exitok $? 0 # don't care about stderr for this one
	cat >t/home/want <<EOF ; diffok
EOF
	expected=$(./safe get secret/existing/dhparam)
	testing $version --no-clobber dhparam functionality with existing data
	./safe --no-clobber dhparam secret/existing/dhparam >t/home/got 2>&1; exitok $? 0
	cat >t/home/want <<EOF ; diffok
Cowardly refusing to generate a Diffie-Hellman key exchange parameters in secret/existing/dhparam as it is already present in Vault
EOF
	./safe --quiet --no-clobber dhparam secret/existing/dhparam >t/home/got 2>&1; exitok $? 0
	cat >t/home/want <<EOF ; diffok
EOF
	./safe get secret/existing/dhparam >t/home/got; exitok $? 0
	cat >t/home/want <<EOF ; diffok
$expected

EOF

	testing $version --no-clobber fmt functionality without existing data
	./safe set secret/existing/to-fmt val=value
	./safe --no-clobber fmt crypt-sha512 secret/existing/to-fmt val crypted >t/home/got 2>&1; exitok $? 0
	cat >t/home/want <<EOF ; diffok
EOF
	expected=$(./safe get secret/existing/to-fmt:crypted)
	testing $version --no-clobber fmt functionality with existing data
	./safe set secret/existing/to-fmt val=value2
	./safe --no-clobber fmt crypt-sha512 secret/existing/to-fmt val crypted >t/home/got 2>&1; exitok $? 0
	cat >t/home/want <<EOF ; diffok
Cowardly refusing to reformat secret/existing/to-fmt:val to crypted as it is already present in Vault
EOF
	./safe --quiet --no-clobber fmt crypt-sha512 secret/existing/to-fmt val crypted >t/home/got 2>&1; exitok $? 0
	cat >t/home/want <<EOF ; diffok
EOF
	./safe get secret/existing/to-fmt:crypted >t/home/got; exitok $? 0
	cat >t/home/want <<EOF ; diffok
$expected
EOF

	testing $version --no-clobber x509 issue functionality without existing data
	./safe --no-clobber x509 issue --ca --name test secret/existing/cert >t/home/got 2>&1; exitok $? 0
	cat >t/home/want <<EOF ; diffok
EOF
	expected=$(./safe get secret/existing/cert)
	testing $version --no-clobber x509 issue functionality with existing data
	./safe --no-clobber x509 issue --ca --name test secret/existing/cert >t/home/got 2>&1; exitok $? 0
	cat >t/home/want <<EOF ; diffok
Cowardly refusing to create a new certificate in secret/existing/cert as it is already present in Vault
EOF
	./safe --quiet --no-clobber x509 issue --ca --name test secret/existing/cert >t/home/got 2>&1; exitok $? 0
	cat >t/home/want <<EOF ; diffok
EOF
	./safe get secret/existing/cert >t/home/got; exitok $? 0
	cat >t/home/want <<EOF ; diffok
$expected

EOF

	./safe --no-clobber x509 revoke --signed-by secret/existing/cert secret/existing/cert >t/home/got 2>&1; exitok $? 0
	cat >t/home/want <<EOF ; diffok
EOF
	testing $version --no-clobber delete functionality
	./safe --no-clobber set secret/existing/to-delete key=val
	./safe --no-clobber delete -f secret/existing/to-delete >t/home/got 2>&1; exitok $? 0
	cat >t/home/want <<EOF ; diffok
EOF
	testing $version --no-clobber recursive delete functionality
	./safe --no-clobber set secret/existing/to-delete key=val
	./safe --no-clobber set secret/existing/to-delete/subkey key=val
	./safe --no-clobber delete -Rf secret/existing/to-delete >t/home/got 2>&1; exitok $? 0
	cat >t/home/want <<EOF ; diffok
EOF

  ###### TREE TESTS ######

	testing $version tree display
	./safe gen secret/tree/alpha     x >/dev/null
	./safe gen secret/tree/g         x >/dev/null
	./safe gen secret/tree/g/a       x >/dev/null
	./safe gen secret/tree/beta/name x >/dev/null
	./safe gen secret/tree/beta/env  x >/dev/null
	./safe gen secret/tree/g/a/m     x >/dev/null
	./safe gen secret/tree/g/a/m/m   x >/dev/null
	./safe gen secret/tree/g/a/m/m/a x >/dev/null
	./safe tree secret/tree >t/home/got 2>t/home/errors
	cat >t/home/want <<EOF
.
└── secret/tree
    ├── alpha
    ├── beta/
    │   ├── env
    │   └── name
    ├── g
    └── g/
        ├── a
        └── a/
            ├── m
            └── m/
                ├── m
                └── m/
                    └── a

EOF
	diffok
	./safe tree -d secret/tree >t/home/got 2>t/home/errors
	cat >t/home/want <<EOF
.
└── secret/tree
    ├── beta/
    └── g/
        └── a/
            └── m/
                └── m/

EOF
	diffok
	./safe tree -d secret/tree >t/home/got 2>t/home/errors
	cat >t/home/want <<EOF
.
└── secret/tree
    ├── beta/
    └── g/
        └── a/
            └── m/
                └── m/

EOF
	diffok

	case ${version} in
	(0.5.0|0.5.2) ;;
	(*)
		testing ${version} tree not found errors
		./safe tree secret/enoent >t/home/got 2>&1
		cat >t/home/want <<EOF
!! no secret exists at path \`secret/enoent\`
EOF
		diffok
		;;
	esac

	testing ${version} tree export
	./safe set secret/export/admin username=admin password=sekrit         >/dev/null
	./safe set secret/export/robot username=bot password=beep-boop mark=2 >/dev/null
	./safe set secret/export/a/b/c subkey='the value given'               >/dev/null
	./safe export secret/export >t/home/got 2>t/home/errors
	cat >t/home/want <<EOF
---
secret/export/admin:
  username: admin
  password: sekrit
secret/export/robot:
  username: bot
  password: beep-boop
  mark: "2"
secret/export/a/b/c:
  subkey: the value given
EOF
	yamlok

	testing ${version} tree import
	cat <<EOF | spruce json >t/home/want
---
secret/import/admin:
  username: admin
  password: sekrit
secret/import/robot:
  username: bot
  password: beep-boop
  mark: "2"
secret/import/a/b/c:
  subkey: the value given
secret/import/a/b/c/d:
  subsubkey: really deep
EOF
	./safe import secret/import <t/home/want >/dev/null
	./safe export secret/import >t/home/got 2>t/home/errors
	yamlok

  testing ${version} tree --keys
  ./safe tree --keys secret/import/a/b/c >t/home/got 2>t/home/errors ; exitok $? 0
  cat <<'EOF' >t/home/want ; diffok
.
└── secret/import/a/b/c
    ├── :subkey
    └── d
        └── :subsubkey

EOF
  ./safe tree --keys secret/import/a secret/import/robot >t/home/got 2>t/home/errors ; exitok $? 0
  cat <<'EOF' >t/home/want ; diffok
.
├── secret/import/a
│   └── b/
│       ├── c
│       │   └── :subkey
│       └── c/
│           └── d
│               └── :subsubkey
└── secret/import/robot
    ├── :mark
    ├── :password
    └── :username

EOF

  testing ${version} paths --keys
  ./safe paths --keys secret/import/a/b/c >t/home/got 2>t/home/errors ; exitok $? 0
  cat <<'EOF' >t/home/want ; diffok
secret/import/a/b/c:subkey
secret/import/a/b/c/d:subsubkey
EOF
  ./safe paths --keys secret/import/a secret/import/robot >t/home/got 2>t/home/errors ; exitok $? 0
  cat <<'EOF' >t/home/want ; diffok
secret/import/a/b/c:subkey
secret/import/a/b/c/d:subsubkey
secret/import/robot:mark
secret/import/robot:password
secret/import/robot:username
EOF

	testing ${version} x509 commands
	./safe x509 issue                                                ; exitok $? 1 # need a path
	./safe x509 issue --signed-by secret/enoent                      ; exitok $? 1 # still need a name...
	./safe x509 issue --signed-by secret/enoent secret/cert          ; exitok $? 1 # ca must exist

	./safe x509 issue secret/x509/self-signed --name www.example.com ; exitok $? 0
	./safe x509 validate secret/x509/self-signed                     ; exitok $? 0
	./safe exists secret/x509/self-signed:certificate                ; exitok $? 0
	./safe exists secret/x509/self-signed:key                        ; exitok $? 0
	./safe exists secret/x509/self-signed:combined                   ; exitok $? 0
	./safe exists secret/x509/self-signed:serial                     ; exitok $? 1  # not a CA
	./safe exists secret/x509/self-signed:crl                        ; exitok $? 1  # not a CA
	./safe x509 check secret/x509/self-signed                        ; exitok $? 0
	./safe x509 check secret/x509/self-signed --for www.example.com  ; exitok $? 0
	./safe x509 check secret/x509/self-signed --for mail.example.com ; exitok $? 1
	./safe x509 check secret/x509/self-signed --for test@example.com ; exitok $? 1
	./safe x509 check secret/x509/self-signed --for 10.40.5.6        ; exitok $? 1

	./safe x509 issue secret/fail-without-name                       ; exitok $? 1
	./safe exists secret/fail-without-name:certificate               ; exitok $? 1
	./safe exists secret/fail-without-name:key                       ; exitok $? 1
	./safe exists secret/fail-without-name:combined                  ; exitok $? 1
	./safe exists secret/fail-without-name:serial                    ; exitok $? 1
	./safe exists secret/fail-without-name:crl                       ; exitok $? 1

	./safe x509 issue secret/x509/ca --name ca.example.com --ca      ; exitok $? 0
	./safe exists secret/x509/ca:certificate                         ; exitok $? 0
	./safe exists secret/x509/ca:key                                 ; exitok $? 0
	./safe exists secret/x509/ca:combined                            ; exitok $? 0
	./safe exists secret/x509/ca:serial                              ; exitok $? 0 # is a CA
	./safe exists secret/x509/ca:crl                                 ; exitok $? 0 # is a CA
	./safe x509 validate secret/x509/ca --ca                         ; exitok $? 0
	./safe x509 validate secret/x509/ca --not-expired                ; exitok $? 0
	./safe x509 validate secret/x509/ca --for ca.example.com         ; exitok $? 0
	./safe x509 validate secret/x509/ca --for www.example.com        ; exitok $? 1
	./safe x509 validate secret/x509/ca --signed-by secret/x509/ca \
	                                    --not-revoked                ; exitok $? 0

	./safe x509 check                                                ; exitok $? 1 # need a path
	./safe x509 check --signed-by secret/enoent                      ; exitok $? 1 # still need a name...
	./safe x509 check --signed-by secret/enoent secret/cert          ; exitok $? 1 # ca must exist
	./safe x509 check --signed-by secret/x509/ca secret/enoent       ; exitok $? 1 # cert must exist

	./safe x509 issue secret/x509/signed --signed-by secret/x509/ca --name mail.example.com
	./safe x509 validate secret/x509/signed --signed-by secret/x509/ca \
	                                        --not-expired \
	                                        --not-revoked \
	                                        --for mail.example.com   ; exitok $? 0

	./safe x509 revoke                                               ; exitok $? 1 # need a path
	./safe x509 revoke --signed-by secret/x509/ca                    ; exitok $? 1 # still need a path...
	./safe x509 revoke --signed-by secret/x509/ca secret/enoent      ; exitok $? 1 # path must exist
	./safe x509 revoke --signed-by secret/enoent secret/x509/signed  ; exitok $? 1 # ca must exist

	./safe x509 crl --renew                                          ; exitok $? 1 # need a path
	./safe x509 crl secret/x509/ca                                   ; exitok $? 1 # need --renew
	./safe x509 crl --renew secret/enoent                            ; exitok $? 1 # path must exist
	./safe x509 crl --renew secret/x509/signed                       ; exitok $? 1 # need a ca
	./safe x509 crl --renew secret/x509/ca                           ; exitok $? 0

	./safe x509 revoke secret/x509/signed --signed-by secret/x509/ca ; exitok $? 0
	./safe x509 validate secret/x509/signed --signed-by secret/x509/ca \
	                                        --not-expired \
	                                        --revoked \
	                                        --for mail.example.com   ; exitok $? 0

	./safe x509 issue secret/x509/multi --signed-by secret/x509/ca \
	                                    --name dns.example.com \
	                                    --name *.dns.example.com \
	                                    --name 10.255.6.7 \
	                                    --name 10.255.6.8 \
	                                    --name admin@example.com \
	                                    --name safe.vault@example.com ; exitok $? 0
	./safe x509 check secret/x509/multi --signed-by secret/x509/ca \
	                                    --not-expired \
	                                    --not-revoked \
	                                    --for dns.example.com \
	                                    --for 10.255.6.7 \
	                                    --for 10.255.6.8 \
	                                    --for admin@example.com \
	                                    --for safe.vault@example.com ; exitok $? 0
	./safe x509 check secret/x509/multi --for whatever.dns.example.com \
	                                    --for anything.dns.example.com \
	                                    --for x.dns.example.com      ; exitok $? 0
	./safe x509 check secret/x509/multi --for x.y.dns.example.com    ; exitok $? 1
	./safe x509 check secret/x509/multi --for x.com                  ; exitok $? 1

	./safe x509 issue secret/x509/wild --signed-by secret/x509/ca \
	                                   --name cn.tld \
	                                   --name '*.tld' \
	                                   --name '*.*.tld' \
	                                   --name '*.*.*.tld'            ; exitok $? 0
	./safe x509 check secret/x509/wild --signed-by secret/x509/ca \
	                                   --for cn.tld \
	                                   --for x.tld \
	                                   --for x.y.tld \
	                                   --for x.y.z.tld               ; exitok $? 0
	./safe x509 check secret/x509/wild --signed-by secret/x509/ca \
	                                   --for tld                     ; exitok $? 1
	./safe x509 check secret/x509/wild --signed-by secret/x509/ca \
	                                   --for w.x.y.z.tld             ; exitok $? 1

	./safe x509 issue secret/x509/weak --bits 1024 -n weak.tld       ; exitok $? 0
	./safe x509 check secret/x509/weak --bits 1024                   ; exitok $? 0
	./safe x509 check secret/x509/weak --bits 2048                   ; exitok $? 1
	./safe x509 check secret/x509/weak --bits 4096                   ; exitok $? 1
	./safe x509 check secret/x509/weak --bits 1024 \
	                                   --bits 2048 \
	                                   --bits 4096                   ; exitok $? 0

	./safe x509 issue secret/x509/meh --bits 2048 -n meh.tld         ; exitok $? 0
	./safe x509 check secret/x509/meh --bits 1024                    ; exitok $? 1
	./safe x509 check secret/x509/meh --bits 2048                    ; exitok $? 0
	./safe x509 check secret/x509/meh --bits 4096                    ; exitok $? 1
	./safe x509 check secret/x509/meh --bits 1024 \
	                                  --bits 2048 \
	                                  --bits 4096                    ; exitok $? 0

	./safe x509 issue secret/x509/strong --bits 4096 -n strong.tld   ; exitok $? 0
	./safe x509 check secret/x509/strong --bits 1024                 ; exitok $? 1
	./safe x509 check secret/x509/strong --bits 2048                 ; exitok $? 1
	./safe x509 check secret/x509/strong --bits 4096                 ; exitok $? 0
	./safe x509 check secret/x509/strong --bits 1024 \
	                                     --bits 2048 \
	                                     --bits 4096                 ; exitok $? 0

	./safe x509 issue secret/x509/bad --bits 1000000000 -n one.mil   ; exitok $? 1

	./safe x509 check secret/x509/weak \
	                  secret/x509/meh \
	                  secret/x509/strong                             ; exitok $? 0

	./safe x509 check secret/x509/weak \
	                  secret/x509/ENOENT \
	                  secret/x509/strong                             ; exitok $? 1

	./safe x509 issue secret/x509/imposter --name x.y.z --ca         ; exitok $? 0
	./safe x509 check secret/x509/imposter --ca                      ; exitok $? 0
	./safe x509 issue secret/x509/imposter --name a.b.c              ; exitok $? 0 # not a CA, now
	./safe x509 check secret/x509/imposter --ca                      ; exitok $? 1 # not a CA

	dump_log
done

